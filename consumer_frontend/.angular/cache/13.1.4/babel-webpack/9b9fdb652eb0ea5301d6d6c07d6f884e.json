{"ast":null,"code":"import _asyncToGenerator from \"C:\\\\Users\\\\Hp\\\\Desktop\\\\Customer Management\\\\consumer_frontend\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\asyncToGenerator.js\";\nimport _wrapAsyncGenerator from \"C:\\\\Users\\\\Hp\\\\Desktop\\\\Customer Management\\\\consumer_frontend\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\wrapAsyncGenerator.js\";\nimport _awaitAsyncGenerator from \"C:\\\\Users\\\\Hp\\\\Desktop\\\\Customer Management\\\\consumer_frontend\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\awaitAsyncGenerator.js\";\nimport _asyncGeneratorDelegate from \"C:\\\\Users\\\\Hp\\\\Desktop\\\\Customer Management\\\\consumer_frontend\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\asyncGeneratorDelegate.js\";\nimport _asyncIterator from \"C:\\\\Users\\\\Hp\\\\Desktop\\\\Customer Management\\\\consumer_frontend\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\asyncIterator.js\";\nexport const streamChunk = function* (chunk, chunkSize) {\n  let len = chunk.byteLength;\n\n  if (!chunkSize || len < chunkSize) {\n    yield chunk;\n    return;\n  }\n\n  let pos = 0;\n  let end;\n\n  while (pos < len) {\n    end = pos + chunkSize;\n    yield chunk.slice(pos, end);\n    pos = end;\n  }\n};\nexport const readBytes = /*#__PURE__*/function () {\n  var _ref = _wrapAsyncGenerator(function* (iterable, chunkSize) {\n    var _iteratorAbruptCompletion = false;\n    var _didIteratorError = false;\n\n    var _iteratorError;\n\n    try {\n      for (var _iterator = _asyncIterator(readStream(iterable)), _step; _iteratorAbruptCompletion = !(_step = yield _awaitAsyncGenerator(_iterator.next())).done; _iteratorAbruptCompletion = false) {\n        const chunk = _step.value;\n        yield* _asyncGeneratorDelegate(_asyncIterator(streamChunk(chunk, chunkSize)), _awaitAsyncGenerator);\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (_iteratorAbruptCompletion && _iterator.return != null) {\n          yield _awaitAsyncGenerator(_iterator.return());\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n  });\n\n  return function readBytes(_x, _x2) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nconst readStream = /*#__PURE__*/function () {\n  var _ref2 = _wrapAsyncGenerator(function* (stream) {\n    if (stream[Symbol.asyncIterator]) {\n      yield* _asyncGeneratorDelegate(_asyncIterator(stream), _awaitAsyncGenerator);\n      return;\n    }\n\n    const reader = stream.getReader();\n\n    try {\n      for (;;) {\n        const {\n          done,\n          value\n        } = yield _awaitAsyncGenerator(reader.read());\n\n        if (done) {\n          break;\n        }\n\n        yield value;\n      }\n    } finally {\n      yield _awaitAsyncGenerator(reader.cancel());\n    }\n  });\n\n  return function readStream(_x3) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n\nexport const trackStream = (stream, chunkSize, onProgress, onFinish) => {\n  const iterator = readBytes(stream, chunkSize);\n  let bytes = 0;\n  let done;\n\n  let _onFinish = e => {\n    if (!done) {\n      done = true;\n      onFinish && onFinish(e);\n    }\n  };\n\n  return new ReadableStream({\n    pull(controller) {\n      return _asyncToGenerator(function* () {\n        try {\n          const {\n            done,\n            value\n          } = yield iterator.next();\n\n          if (done) {\n            _onFinish();\n\n            controller.close();\n            return;\n          }\n\n          let len = value.byteLength;\n\n          if (onProgress) {\n            let loadedBytes = bytes += len;\n            onProgress(loadedBytes);\n          }\n\n          controller.enqueue(new Uint8Array(value));\n        } catch (err) {\n          _onFinish(err);\n\n          throw err;\n        }\n      })();\n    },\n\n    cancel(reason) {\n      _onFinish(reason);\n\n      return iterator.return();\n    }\n\n  }, {\n    highWaterMark: 2\n  });\n};","map":{"version":3,"sources":["C:/Users/Hp/Desktop/Customer Management/consumer_frontend/node_modules/axios/lib/helpers/trackStream.js"],"names":["streamChunk","chunk","chunkSize","len","byteLength","pos","end","slice","readBytes","iterable","readStream","stream","Symbol","asyncIterator","reader","getReader","done","value","read","cancel","trackStream","onProgress","onFinish","iterator","bytes","_onFinish","e","ReadableStream","pull","controller","next","close","loadedBytes","enqueue","Uint8Array","err","reason","return","highWaterMark"],"mappings":"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","sourcesContent":["\nexport const streamChunk = function* (chunk, chunkSize) {\n  let len = chunk.byteLength;\n\n  if (!chunkSize || len < chunkSize) {\n    yield chunk;\n    return;\n  }\n\n  let pos = 0;\n  let end;\n\n  while (pos < len) {\n    end = pos + chunkSize;\n    yield chunk.slice(pos, end);\n    pos = end;\n  }\n}\n\nexport const readBytes = async function* (iterable, chunkSize) {\n  for await (const chunk of readStream(iterable)) {\n    yield* streamChunk(chunk, chunkSize);\n  }\n}\n\nconst readStream = async function* (stream) {\n  if (stream[Symbol.asyncIterator]) {\n    yield* stream;\n    return;\n  }\n\n  const reader = stream.getReader();\n  try {\n    for (;;) {\n      const {done, value} = await reader.read();\n      if (done) {\n        break;\n      }\n      yield value;\n    }\n  } finally {\n    await reader.cancel();\n  }\n}\n\nexport const trackStream = (stream, chunkSize, onProgress, onFinish) => {\n  const iterator = readBytes(stream, chunkSize);\n\n  let bytes = 0;\n  let done;\n  let _onFinish = (e) => {\n    if (!done) {\n      done = true;\n      onFinish && onFinish(e);\n    }\n  }\n\n  return new ReadableStream({\n    async pull(controller) {\n      try {\n        const {done, value} = await iterator.next();\n\n        if (done) {\n         _onFinish();\n          controller.close();\n          return;\n        }\n\n        let len = value.byteLength;\n        if (onProgress) {\n          let loadedBytes = bytes += len;\n          onProgress(loadedBytes);\n        }\n        controller.enqueue(new Uint8Array(value));\n      } catch (err) {\n        _onFinish(err);\n        throw err;\n      }\n    },\n    cancel(reason) {\n      _onFinish(reason);\n      return iterator.return();\n    }\n  }, {\n    highWaterMark: 2\n  })\n}\n"]},"metadata":{},"sourceType":"module"}