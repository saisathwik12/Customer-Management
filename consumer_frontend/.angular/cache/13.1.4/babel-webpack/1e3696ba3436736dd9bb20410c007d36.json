{"ast":null,"code":"import _asyncToGenerator from \"C:\\\\Users\\\\Hp\\\\Desktop\\\\Customer Management\\\\consumer_frontend\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\asyncToGenerator.js\";\nimport platform from \"../platform/index.js\";\nimport utils from \"../utils.js\";\nimport AxiosError from \"../core/AxiosError.js\";\nimport composeSignals from \"../helpers/composeSignals.js\";\nimport { trackStream } from \"../helpers/trackStream.js\";\nimport AxiosHeaders from \"../core/AxiosHeaders.js\";\nimport { progressEventReducer, progressEventDecorator, asyncDecorator } from \"../helpers/progressEventReducer.js\";\nimport resolveConfig from \"../helpers/resolveConfig.js\";\nimport settle from \"../core/settle.js\";\nconst DEFAULT_CHUNK_SIZE = 64 * 1024;\nconst {\n  isFunction\n} = utils;\n\nconst globalFetchAPI = (({\n  Request,\n  Response\n}) => ({\n  Request,\n  Response\n}))(utils.global);\n\nconst {\n  ReadableStream,\n  TextEncoder\n} = utils.global;\n\nconst test = (fn, ...args) => {\n  try {\n    return !!fn(...args);\n  } catch (e) {\n    return false;\n  }\n};\n\nconst factory = env => {\n  env = utils.merge.call({\n    skipUndefined: true\n  }, globalFetchAPI, env);\n  const {\n    fetch: envFetch,\n    Request,\n    Response\n  } = env;\n  const isFetchSupported = envFetch ? isFunction(envFetch) : typeof fetch === 'function';\n  const isRequestSupported = isFunction(Request);\n  const isResponseSupported = isFunction(Response);\n\n  if (!isFetchSupported) {\n    return false;\n  }\n\n  const isReadableStreamSupported = isFetchSupported && isFunction(ReadableStream);\n  const encodeText = isFetchSupported && (typeof TextEncoder === 'function' ? (encoder => str => encoder.encode(str))(new TextEncoder()) : /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator(function* (str) {\n      return new Uint8Array(yield new Request(str).arrayBuffer());\n    });\n\n    return function (_x) {\n      return _ref.apply(this, arguments);\n    };\n  }());\n  const supportsRequestStream = isRequestSupported && isReadableStreamSupported && test(() => {\n    let duplexAccessed = false;\n    const hasContentType = new Request(platform.origin, {\n      body: new ReadableStream(),\n      method: 'POST',\n\n      get duplex() {\n        duplexAccessed = true;\n        return 'half';\n      }\n\n    }).headers.has('Content-Type');\n    return duplexAccessed && !hasContentType;\n  });\n  const supportsResponseStream = isResponseSupported && isReadableStreamSupported && test(() => utils.isReadableStream(new Response('').body));\n  const resolvers = {\n    stream: supportsResponseStream && (res => res.body)\n  };\n  isFetchSupported && (() => {\n    ['text', 'arrayBuffer', 'blob', 'formData', 'stream'].forEach(type => {\n      !resolvers[type] && (resolvers[type] = (res, config) => {\n        let method = res && res[type];\n\n        if (method) {\n          return method.call(res);\n        }\n\n        throw new AxiosError(`Response type '${type}' is not supported`, AxiosError.ERR_NOT_SUPPORT, config);\n      });\n    });\n  })();\n\n  const getBodyLength = /*#__PURE__*/function () {\n    var _ref2 = _asyncToGenerator(function* (body) {\n      if (body == null) {\n        return 0;\n      }\n\n      if (utils.isBlob(body)) {\n        return body.size;\n      }\n\n      if (utils.isSpecCompliantForm(body)) {\n        const _request = new Request(platform.origin, {\n          method: 'POST',\n          body\n        });\n\n        return (yield _request.arrayBuffer()).byteLength;\n      }\n\n      if (utils.isArrayBufferView(body) || utils.isArrayBuffer(body)) {\n        return body.byteLength;\n      }\n\n      if (utils.isURLSearchParams(body)) {\n        body = body + '';\n      }\n\n      if (utils.isString(body)) {\n        return (yield encodeText(body)).byteLength;\n      }\n    });\n\n    return function getBodyLength(_x2) {\n      return _ref2.apply(this, arguments);\n    };\n  }();\n\n  const resolveBodyLength = /*#__PURE__*/function () {\n    var _ref3 = _asyncToGenerator(function* (headers, body) {\n      const length = utils.toFiniteNumber(headers.getContentLength());\n      return length == null ? getBodyLength(body) : length;\n    });\n\n    return function resolveBodyLength(_x3, _x4) {\n      return _ref3.apply(this, arguments);\n    };\n  }();\n\n  return /*#__PURE__*/function () {\n    var _ref4 = _asyncToGenerator(function* (config) {\n      let {\n        url,\n        method,\n        data,\n        signal,\n        cancelToken,\n        timeout,\n        onDownloadProgress,\n        onUploadProgress,\n        responseType,\n        headers,\n        withCredentials = 'same-origin',\n        fetchOptions\n      } = resolveConfig(config);\n\n      let _fetch = envFetch || fetch;\n\n      responseType = responseType ? (responseType + '').toLowerCase() : 'text';\n      let composedSignal = composeSignals([signal, cancelToken && cancelToken.toAbortSignal()], timeout);\n      let request = null;\n\n      const unsubscribe = composedSignal && composedSignal.unsubscribe && (() => {\n        composedSignal.unsubscribe();\n      });\n\n      let requestContentLength;\n\n      try {\n        if (onUploadProgress && supportsRequestStream && method !== 'get' && method !== 'head' && (requestContentLength = yield resolveBodyLength(headers, data)) !== 0) {\n          let _request = new Request(url, {\n            method: 'POST',\n            body: data,\n            duplex: \"half\"\n          });\n\n          let contentTypeHeader;\n\n          if (utils.isFormData(data) && (contentTypeHeader = _request.headers.get('content-type'))) {\n            headers.setContentType(contentTypeHeader);\n          }\n\n          if (_request.body) {\n            const [onProgress, flush] = progressEventDecorator(requestContentLength, progressEventReducer(asyncDecorator(onUploadProgress)));\n            data = trackStream(_request.body, DEFAULT_CHUNK_SIZE, onProgress, flush);\n          }\n        }\n\n        if (!utils.isString(withCredentials)) {\n          withCredentials = withCredentials ? 'include' : 'omit';\n        } // Cloudflare Workers throws when credentials are defined\n        // see https://github.com/cloudflare/workerd/issues/902\n\n\n        const isCredentialsSupported = isRequestSupported && \"credentials\" in Request.prototype;\n        const resolvedOptions = { ...fetchOptions,\n          signal: composedSignal,\n          method: method.toUpperCase(),\n          headers: headers.normalize().toJSON(),\n          body: data,\n          duplex: \"half\",\n          credentials: isCredentialsSupported ? withCredentials : undefined\n        };\n        request = isRequestSupported && new Request(url, resolvedOptions);\n        let response = yield isRequestSupported ? _fetch(request, fetchOptions) : _fetch(url, resolvedOptions);\n        const isStreamResponse = supportsResponseStream && (responseType === 'stream' || responseType === 'response');\n\n        if (supportsResponseStream && (onDownloadProgress || isStreamResponse && unsubscribe)) {\n          const options = {};\n          ['status', 'statusText', 'headers'].forEach(prop => {\n            options[prop] = response[prop];\n          });\n          const responseContentLength = utils.toFiniteNumber(response.headers.get('content-length'));\n          const [onProgress, flush] = onDownloadProgress && progressEventDecorator(responseContentLength, progressEventReducer(asyncDecorator(onDownloadProgress), true)) || [];\n          response = new Response(trackStream(response.body, DEFAULT_CHUNK_SIZE, onProgress, () => {\n            flush && flush();\n            unsubscribe && unsubscribe();\n          }), options);\n        }\n\n        responseType = responseType || 'text';\n        let responseData = yield resolvers[utils.findKey(resolvers, responseType) || 'text'](response, config);\n        !isStreamResponse && unsubscribe && unsubscribe();\n        return yield new Promise((resolve, reject) => {\n          settle(resolve, reject, {\n            data: responseData,\n            headers: AxiosHeaders.from(response.headers),\n            status: response.status,\n            statusText: response.statusText,\n            config,\n            request\n          });\n        });\n      } catch (err) {\n        unsubscribe && unsubscribe();\n\n        if (err && err.name === 'TypeError' && /Load failed|fetch/i.test(err.message)) {\n          throw Object.assign(new AxiosError('Network Error', AxiosError.ERR_NETWORK, config, request), {\n            cause: err.cause || err\n          });\n        }\n\n        throw AxiosError.from(err, err && err.code, config, request);\n      }\n    });\n\n    return function (_x5) {\n      return _ref4.apply(this, arguments);\n    };\n  }();\n};\n\nconst seedCache = new Map();\nexport const getFetch = config => {\n  let env = config ? config.env : {};\n  const {\n    fetch,\n    Request,\n    Response\n  } = env;\n  const seeds = [Request, Response, fetch];\n  let len = seeds.length,\n      i = len,\n      seed,\n      target,\n      map = seedCache;\n\n  while (i--) {\n    seed = seeds[i];\n    target = map.get(seed);\n    target === undefined && map.set(seed, target = i ? new Map() : factory(env));\n    map = target;\n  }\n\n  return target;\n};\nconst adapter = getFetch();\nexport default adapter;","map":{"version":3,"sources":["C:/Users/Hp/Desktop/Customer Management/consumer_frontend/node_modules/axios/lib/adapters/fetch.js"],"names":["platform","utils","AxiosError","composeSignals","trackStream","AxiosHeaders","progressEventReducer","progressEventDecorator","asyncDecorator","resolveConfig","settle","DEFAULT_CHUNK_SIZE","isFunction","globalFetchAPI","Request","Response","global","ReadableStream","TextEncoder","test","fn","args","e","factory","env","merge","call","skipUndefined","fetch","envFetch","isFetchSupported","isRequestSupported","isResponseSupported","isReadableStreamSupported","encodeText","encoder","str","encode","Uint8Array","arrayBuffer","supportsRequestStream","duplexAccessed","hasContentType","origin","body","method","duplex","headers","has","supportsResponseStream","isReadableStream","resolvers","stream","res","forEach","type","config","ERR_NOT_SUPPORT","getBodyLength","isBlob","size","isSpecCompliantForm","_request","byteLength","isArrayBufferView","isArrayBuffer","isURLSearchParams","isString","resolveBodyLength","length","toFiniteNumber","getContentLength","url","data","signal","cancelToken","timeout","onDownloadProgress","onUploadProgress","responseType","withCredentials","fetchOptions","_fetch","toLowerCase","composedSignal","toAbortSignal","request","unsubscribe","requestContentLength","contentTypeHeader","isFormData","get","setContentType","onProgress","flush","isCredentialsSupported","prototype","resolvedOptions","toUpperCase","normalize","toJSON","credentials","undefined","response","isStreamResponse","options","prop","responseContentLength","responseData","findKey","Promise","resolve","reject","from","status","statusText","err","name","message","Object","assign","ERR_NETWORK","cause","code","seedCache","Map","getFetch","seeds","len","i","seed","target","map","set","adapter"],"mappings":"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","sourcesContent":["import platform from \"../platform/index.js\";\nimport utils from \"../utils.js\";\nimport AxiosError from \"../core/AxiosError.js\";\nimport composeSignals from \"../helpers/composeSignals.js\";\nimport {trackStream} from \"../helpers/trackStream.js\";\nimport AxiosHeaders from \"../core/AxiosHeaders.js\";\nimport {progressEventReducer, progressEventDecorator, asyncDecorator} from \"../helpers/progressEventReducer.js\";\nimport resolveConfig from \"../helpers/resolveConfig.js\";\nimport settle from \"../core/settle.js\";\n\nconst DEFAULT_CHUNK_SIZE = 64 * 1024;\n\nconst {isFunction} = utils;\n\nconst globalFetchAPI = (({Request, Response}) => ({\n  Request, Response\n}))(utils.global);\n\nconst {\n  ReadableStream, TextEncoder\n} = utils.global;\n\n\nconst test = (fn, ...args) => {\n  try {\n    return !!fn(...args);\n  } catch (e) {\n    return false\n  }\n}\n\nconst factory = (env) => {\n  env = utils.merge.call({\n    skipUndefined: true\n  }, globalFetchAPI, env);\n\n  const {fetch: envFetch, Request, Response} = env;\n  const isFetchSupported = envFetch ? isFunction(envFetch) : typeof fetch === 'function';\n  const isRequestSupported = isFunction(Request);\n  const isResponseSupported = isFunction(Response);\n\n  if (!isFetchSupported) {\n    return false;\n  }\n\n  const isReadableStreamSupported = isFetchSupported && isFunction(ReadableStream);\n\n  const encodeText = isFetchSupported && (typeof TextEncoder === 'function' ?\n      ((encoder) => (str) => encoder.encode(str))(new TextEncoder()) :\n      async (str) => new Uint8Array(await new Request(str).arrayBuffer())\n  );\n\n  const supportsRequestStream = isRequestSupported && isReadableStreamSupported && test(() => {\n    let duplexAccessed = false;\n\n    const hasContentType = new Request(platform.origin, {\n      body: new ReadableStream(),\n      method: 'POST',\n      get duplex() {\n        duplexAccessed = true;\n        return 'half';\n      },\n    }).headers.has('Content-Type');\n\n    return duplexAccessed && !hasContentType;\n  });\n\n  const supportsResponseStream = isResponseSupported && isReadableStreamSupported &&\n    test(() => utils.isReadableStream(new Response('').body));\n\n  const resolvers = {\n    stream: supportsResponseStream && ((res) => res.body)\n  };\n\n  isFetchSupported && ((() => {\n    ['text', 'arrayBuffer', 'blob', 'formData', 'stream'].forEach(type => {\n      !resolvers[type] && (resolvers[type] = (res, config) => {\n        let method = res && res[type];\n\n        if (method) {\n          return method.call(res);\n        }\n\n        throw new AxiosError(`Response type '${type}' is not supported`, AxiosError.ERR_NOT_SUPPORT, config);\n      })\n    });\n  })());\n\n  const getBodyLength = async (body) => {\n    if (body == null) {\n      return 0;\n    }\n\n    if (utils.isBlob(body)) {\n      return body.size;\n    }\n\n    if (utils.isSpecCompliantForm(body)) {\n      const _request = new Request(platform.origin, {\n        method: 'POST',\n        body,\n      });\n      return (await _request.arrayBuffer()).byteLength;\n    }\n\n    if (utils.isArrayBufferView(body) || utils.isArrayBuffer(body)) {\n      return body.byteLength;\n    }\n\n    if (utils.isURLSearchParams(body)) {\n      body = body + '';\n    }\n\n    if (utils.isString(body)) {\n      return (await encodeText(body)).byteLength;\n    }\n  }\n\n  const resolveBodyLength = async (headers, body) => {\n    const length = utils.toFiniteNumber(headers.getContentLength());\n\n    return length == null ? getBodyLength(body) : length;\n  }\n\n  return async (config) => {\n    let {\n      url,\n      method,\n      data,\n      signal,\n      cancelToken,\n      timeout,\n      onDownloadProgress,\n      onUploadProgress,\n      responseType,\n      headers,\n      withCredentials = 'same-origin',\n      fetchOptions\n    } = resolveConfig(config);\n\n    let _fetch = envFetch || fetch;\n\n    responseType = responseType ? (responseType + '').toLowerCase() : 'text';\n\n    let composedSignal = composeSignals([signal, cancelToken && cancelToken.toAbortSignal()], timeout);\n\n    let request = null;\n\n    const unsubscribe = composedSignal && composedSignal.unsubscribe && (() => {\n      composedSignal.unsubscribe();\n    });\n\n    let requestContentLength;\n\n    try {\n      if (\n        onUploadProgress && supportsRequestStream && method !== 'get' && method !== 'head' &&\n        (requestContentLength = await resolveBodyLength(headers, data)) !== 0\n      ) {\n        let _request = new Request(url, {\n          method: 'POST',\n          body: data,\n          duplex: \"half\"\n        });\n\n        let contentTypeHeader;\n\n        if (utils.isFormData(data) && (contentTypeHeader = _request.headers.get('content-type'))) {\n          headers.setContentType(contentTypeHeader)\n        }\n\n        if (_request.body) {\n          const [onProgress, flush] = progressEventDecorator(\n            requestContentLength,\n            progressEventReducer(asyncDecorator(onUploadProgress))\n          );\n\n          data = trackStream(_request.body, DEFAULT_CHUNK_SIZE, onProgress, flush);\n        }\n      }\n\n      if (!utils.isString(withCredentials)) {\n        withCredentials = withCredentials ? 'include' : 'omit';\n      }\n\n      // Cloudflare Workers throws when credentials are defined\n      // see https://github.com/cloudflare/workerd/issues/902\n      const isCredentialsSupported = isRequestSupported && \"credentials\" in Request.prototype;\n\n      const resolvedOptions = {\n        ...fetchOptions,\n        signal: composedSignal,\n        method: method.toUpperCase(),\n        headers: headers.normalize().toJSON(),\n        body: data,\n        duplex: \"half\",\n        credentials: isCredentialsSupported ? withCredentials : undefined\n      };\n\n      request = isRequestSupported && new Request(url, resolvedOptions);\n\n      let response = await (isRequestSupported ? _fetch(request, fetchOptions) : _fetch(url, resolvedOptions));\n\n      const isStreamResponse = supportsResponseStream && (responseType === 'stream' || responseType === 'response');\n\n      if (supportsResponseStream && (onDownloadProgress || (isStreamResponse && unsubscribe))) {\n        const options = {};\n\n        ['status', 'statusText', 'headers'].forEach(prop => {\n          options[prop] = response[prop];\n        });\n\n        const responseContentLength = utils.toFiniteNumber(response.headers.get('content-length'));\n\n        const [onProgress, flush] = onDownloadProgress && progressEventDecorator(\n          responseContentLength,\n          progressEventReducer(asyncDecorator(onDownloadProgress), true)\n        ) || [];\n\n        response = new Response(\n          trackStream(response.body, DEFAULT_CHUNK_SIZE, onProgress, () => {\n            flush && flush();\n            unsubscribe && unsubscribe();\n          }),\n          options\n        );\n      }\n\n      responseType = responseType || 'text';\n\n      let responseData = await resolvers[utils.findKey(resolvers, responseType) || 'text'](response, config);\n\n      !isStreamResponse && unsubscribe && unsubscribe();\n\n      return await new Promise((resolve, reject) => {\n        settle(resolve, reject, {\n          data: responseData,\n          headers: AxiosHeaders.from(response.headers),\n          status: response.status,\n          statusText: response.statusText,\n          config,\n          request\n        })\n      })\n    } catch (err) {\n      unsubscribe && unsubscribe();\n\n      if (err && err.name === 'TypeError' && /Load failed|fetch/i.test(err.message)) {\n        throw Object.assign(\n          new AxiosError('Network Error', AxiosError.ERR_NETWORK, config, request),\n          {\n            cause: err.cause || err\n          }\n        )\n      }\n\n      throw AxiosError.from(err, err && err.code, config, request);\n    }\n  }\n}\n\nconst seedCache = new Map();\n\nexport const getFetch = (config) => {\n  let env = config ? config.env : {};\n  const {fetch, Request, Response} = env;\n  const seeds = [\n    Request, Response, fetch\n  ];\n\n  let len = seeds.length, i = len,\n    seed, target, map = seedCache;\n\n  while (i--) {\n    seed = seeds[i];\n    target = map.get(seed);\n\n    target === undefined && map.set(seed, target = (i ? new Map() : factory(env)))\n\n    map = target;\n  }\n\n  return target;\n};\n\nconst adapter = getFetch();\n\nexport default adapter;\n"]},"metadata":{},"sourceType":"module"}